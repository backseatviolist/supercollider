title:: Writing Unit Generators
summary:: Get started with writing unit generators
categories:: Internals

section:: Pseudo-ugens

Pseudo-ugens are useful when you want to abbreviate a certain configuration of UGens that gets used repeatedly. A pseudo-ugen is a class that superficially resembles a UGen class, but it only returns a composition of existing UGens. Pseudo-ugens exist only in the client -- the server isn't aware of them and only receives their components.

The below example has only a code::.ar:: method, but you can just as easily have both code::.ar:: and code::.kr:: methods.

code::
BoringMixer {
    *ar { arg left, right;
        ^(left + right) * 0.5;
    }
}
::

Examples of pseudo-ugens found in SC include link::Classes/BLowPass4:: and link::Classes/BHiPass4::, which break down into link::Classes/SOS:: UGens.

There are very few restrictions on what these classes can contain, but you should keep the following in mind:

list::
## It is courteous to leave a note in your class's help file that identifies it as a pseudo-ugen.
## To avoid confusion, pseudo-ugens should not inherit from the base class link::Classes/UGen::.
## A SynthDef can only have two link::Classes/LocalIn::/link::Classes/LocalOut:: pairings â€” one for control rate and one for audio rate. Putting LocalIn and LocalOut in a pseudo-ugen is a bad idea, as it could interfere with other feedback loops in the SynthDef.
::

section:: Basics of real UGens

A real UGen needs two components: a plugin for the server, and a class for the language. The class goes in an ordinary code::*.sc:: file, and defines the interface for your UGen in the language. This class is generally just a few lines of code that ultimately call the class method link::Classes/UGen#-multiNew::.

The server plugin is where the actual UGen behavior is defined. It is given by a platform-dependent library file: code::*.so:: for *nix, code::*.dll:: for Windows, and code::*.scx:: for OS X [fact check needed on the last two -NH]. A library file can contain more than one UGen.

When scsynth boots, it will look for such library files in code::Platform.userExtensionDir::. Since sclang also looks for class files in the same location, the class file and the library file can go in the same place.

section:: FAUST (the easy way)

note:: This section is currently Linux only. Please expand to include instructions for other platforms. ::

FAUST footnote::http://faust.grame.fr/:: is an open source DSP language that describes real-time audio units. Its greatest strength is that it can be compiled into a huge variety of contexts: standalone GUI applications, Flash plugins, Max/MSP or Pure Data externals, CSOUND opcodes, VST plugins, etc. It can also compile to SuperCollider plugins, providing the easiest way to create real UGens in SuperCollider.

First, write a FAUST program such as the below:

code::
process = + : *(0.5);
::

which is a boring ugen that just averages its two inputs. Save this as BoringMixer.dsp, and run the following at the command line:

code::
faust2supercollider BoringMixer.dsp
::

This will generate BoringMixer.sc and BoringMixer.so files in the current directory. Both of these need to go into your extensions directory. After installing them, reboot both the interpreter and the server, and a class named code::FaustBoringMixer:: should show up in sclang. You can verify that code::FaustBoringMixer.ar:: and code::FaustBoringMixer.kr:: both work as expected.

section:: FAUST (the hard way)

note:: This section is currently Linux only. Please expand to include instructions for other platforms. ::

faust2supercollider is not actually the FAUST compiler. It's a handy shell script that hides a somewhat more complicated process: first, it compiles your FAUST .dsp file into a C++ file with the SuperCollider architecture, and then into a shared library usable by scsynth. It generates a file for sclang on the side.

On another note, it would be nice to get rid of the Faust prefix on our ugen. We'll take this as an opportunity to walk through the above manual process, making for a good transition into hand-written C++ ugens. Get yourself into an empty directory, drop your DSP file there and compile into C++ with the following command:

code::
faust -a supercollider.cpp BoringMixer.dsp -o BoringMixer.cpp
::

This is the actual FAUST compiler. We're compiling BoringMixer.dsp using the SuperCollider architecture (as indicated by the argument to the -a option) and writing output to BoringMixer.cpp.

Next we'll set up a build system with CMake. This is overkill for just compiling one ugen, but this results in a rigorous, cross-platform environment that we'll be using again when we start constructing UGens by hand. Create a file in the same directory called `CMakeLists.txt` and add the following:

code::
cmake_minimum_required (VERSION 2.8)
project (MyUGens)

include_directories(${SC_PATH}/include/plugin_interface)
include_directories(${SC_PATH}/include/common)
include_directories(${SC_PATH}/external_libraries/libsndfile/)

set(CMAKE_SHARED_MODULE_PREFIX "")
if(APPLE OR WIN32)
set(CMAKE_SHARED_MODULE_SUFFIX ".scx")
endif()

add_library(BoringMixer MODULE BoringMixer.cpp)
::

You can replace the MyUGens name with anything else.

To compile, you'll need to have a copy of the SuperCollider source code sitting around (since your plugin uses includes provided by SC). Having obtained that:

code::
cmake -G "Unix Makefiles" -DSC_PATH=/path/to/SuperCollider-Source/
make
::

If all goes well, compilation will complete and a file named BoringMixer.so should show up in the current directory.

We'll also create an sclang class file by hand:

code::
BoringMixer : UGen {
	*ar { |left, right|
		^this.multiNew('audio', left, right);
	}
}
::

Save this as BoringMixer.sc (although any name will do, really) and copy both the .so file and the .sc file into somewhere in the code::Platform.userExtensionDir:: directory. Reboot the interpreter and server and you will have a working code::BoringMixer:: ugen.

section:: How Unit Generator plug-ins work.

The server loads unit generator plug-ins when it starts up. Unit Generator plug-ins are dynamically loaded libraries
written in C++. Each library may contain one or multiple unit generator definitions. A plug-in can also define things
other than unit generators such as buffer fill ("/b_gen") commands. Plug-ins are loaded during the startup of the
synthesis server. Therefore the server will have to be restarted after (re-)compiling the plugin.


section:: The Entry Point

When the library is loaded the server calls a function in the library, which is defined by the code::PluginLoad()::
macro.  This entry point has two responsibilities:

list::
## It needs to store the passed in pointer to the InterfaceTable in a global variable.
## It registers the unit generators.
::

Unit Generators are defined by calling a function in the InterfaceTable and passing it the name of the unit generator,
the size of its C data struct, and pointers to functions for constructing and destructing it. There are 4 macros, which
can be used to simplify the process.

definitionList::
## DefineSimpleUnit || Define a `simple' unit generator
## DefineDtorUnit || Define a unit generator with a destructor
## DefineSimpleCantAliasUnit || Define a `simple' unit generator, whose input and output buffers cannot alias
## DefineDtorCantAliasUnit || Define a unit generator with a destructor, whose input and output buffers cannot alias
::

These macros depend on a specific naming convention:
list::
## The unit generator struct is named like the plug-in.
## The unit generator constructor is named code::PluginName_Ctor::
## The unit generator destructor is named code::PluginName_Dtor::
::


section:: A Simple Unit Generator Plugin

Unit generator plugins require two parts: A C++ part, which implements the server-side code that is loaded as a
dynamically loaded library, and an SCLang class, that is required to build the link::Classes/SynthDef::. The following
example implements a simple Sawtooth oscillator

subsection:: C++-side Definition of Unit Generators

The following code shows the C++ source of a simple unit generator.

code::
#include "SC_PlugIn.h"

// InterfaceTable contains pointers to functions in the host (server).
static InterfaceTable *ft;

// declare struct to hold unit generator state
struct MySaw : public Unit
{
	double mPhase; // phase of the oscillator, from -1 to 1.
	float mFreqMul; // a constant for multiplying frequency
};

// declare unit generator functions
static void MySaw_next_a(MySaw *unit, int inNumSamples);
static void MySaw_next_k(MySaw *unit, int inNumSamples);
static void MySaw_Ctor(MySaw* unit);


//////////////////////////////////////////////////////////////////

// Ctor is called to initialize the unit generator.
// It only executes once.

// A Ctor usually does 3 things.
// 1. set the calculation function.
// 2. initialize the unit generator state variables.
// 3. calculate one sample of output.
void MySaw_Ctor(MySaw* unit)
{
	// 1. set the calculation function.
	if (INRATE(0) == calc_FullRate) {
		// if the frequency argument is audio rate
		SETCALC(MySaw_next_a);
	} else {
		// if the frequency argument is control rate (or a scalar).
		SETCALC(MySaw_next_k);
	}

	// 2. initialize the unit generator state variables.
	// initialize a constant for multiplying the frequency
	unit->mFreqMul = 2.0 * SAMPLEDUR;
	// get initial phase of oscillator
	unit->mPhase = IN0(1);

	// 3. calculate one sample of output.
	MySaw_next_k(unit, 1);
}


//////////////////////////////////////////////////////////////////

// The calculation function executes once per control period
// which is typically 64 samples.

// calculation function for an audio rate frequency argument
void MySaw_next_a(MySaw *unit, int inNumSamples)
{
	// get the pointer to the output buffer
	float *out = OUT(0);

	// get the pointer to the input buffer
	float *freq = IN(0);

	// get phase and freqmul constant from struct and store it in a
	// local variable.
	// The optimizer will cause them to be loaded it into a register.
	float freqmul = unit->mFreqMul;
	double phase = unit->mPhase;

	// perform a loop for the number of samples in the control period.
	// If this unit is audio rate then inNumSamples will be 64 or whatever
	// the block size is. If this unit is control rate then inNumSamples will
	// be 1.
	for (int i=0; i < inNumSamples; ++i)
	{
		// out must be written last for in place operation
		float z = phase;
		phase += freq[i] * freqmul;

		// these if statements wrap the phase a +1 or -1.
		if (phase >= 1.f) phase -= 2.f;
		else if (phase <= -1.f) phase += 2.f;

		// write the output
		out[i] = z;
	}

	// store the phase back to the struct
	unit->mPhase = phase;
}

//////////////////////////////////////////////////////////////////

// calculation function for a control rate frequency argument
void MySaw_next_k(MySaw *unit, int inNumSamples)
{
	// get the pointer to the output buffer
	float *out = OUT(0);

	// freq is control rate, so calculate it once.
	float freq = IN0(0) * unit->mFreqMul;

	// get phase from struct and store it in a local variable.
	// The optimizer will cause it to be loaded it into a register.
	double phase = unit->mPhase;

	// since the frequency is not changing then we can simplify the loops
	// by separating the cases of positive or negative frequencies.
	// This will make them run faster because there is less code inside the loop.
	if (freq >= 0.f) {
		// positive frequencies
		for (int i=0; i < inNumSamples; ++i)
		{
			out[i] = phase;
			phase += freq;
			if (phase >= 1.f) phase -= 2.f;
		}
	} else {
		// negative frequencies
		for (int i=0; i < inNumSamples; ++i)
		{
			out[i] = phase;
			phase += freq;
			if (phase <= -1.f) phase += 2.f;
		}
	}

	// store the phase back to the struct
	unit->mPhase = phase;
}


// the entry point is called by the host when the plug-in is loaded
PluginLoad(MySaw)
{
    // InterfaceTable *inTable implicitly given as argument to the load function
	ft = inTable; // store pointer to InterfaceTable

	DefineSimpleUnit(MySaw);
}
::

subsection:: SCLang-side Definition of Unit Generators

SuperCollider requires an SCLang class in order to build SynthDefs.

The arguments to the MySaw UGen are code::freq:: and code::iphase::.  The code::multiNew:: method handles multi channel
expansion.  The code::madd:: method provides support for the mul and add arguments. It will create a MulAdd UGen if
necessary. You could write the class without mul and add arguments, but providing them makes it more convenient for the
user. See link::Guides/WritingClasses:: for details on writing sclang classes.

code::
// without mul and add.
MySaw : UGen {
	*ar { arg freq = 440.0, iphase = 0.0;
		^this.multiNew('audio', freq, iphase)
	}
	*kr { arg freq = 440.0, iphase = 0.0;
		^this.multiNew('control', freq, iphase)
	}
}
::

subsection:: Building Unit Generator Plugins

The most portable way to build plugins is using cmake footnote::http://www.cmake.org::, a cross-platform build
system. In order build the example with cmake, the following code should go into a code::CMakeLists.txt:: file.

code::
cmake_minimum_required (VERSION 2.8)
project (MySaw)

include_directories(${SC_PATH}/include/plugin_interface)
include_directories(${SC_PATH}/include/common)
include_directories(${SC_PATH}/external_libraries/libsndfile/)

set(CMAKE_SHARED_MODULE_PREFIX "")
if(APPLE OR WIN32)
set(CMAKE_SHARED_MODULE_SUFFIX ".scx")
endif()

add_library(MySaw MODULE MySaw.cpp)
::


section:: Coding Guidelines

Unit generator plugins are called from the real-time context, which means that special care needs to be taken in order
to avoid audio dropouts.

definitionList::
## Memory Allocation || Do not allocate memory from the OS via code::malloc:: / code::free:: or code::new::/ code::delete::.
                        Instead you should use the real-time memory allocator via code::RTAlloc:: / code::RTFree::.
## STL Containers || It is generally not recommended to use STL containers, since they internally allocate memory. The only
                     way the STL containers can be used is by providing an Allocator, which maps to the allocating functions of
                     the server.
## Blocking API Calls || Unit generators should not call any code, which could block the execution of the current thread. In
                         particular, system calls should be avoided. If synchronization with other threads is required, this has to be
                         done in a lock-free manner.
::


section:: Thread Safety

There are two different implementations of the SuperCollider server. strong::scsynth:: is the traditional server and
strong::supernova:: is a new implementation with support for multi-processor audio synthesis. Since the plugins in
strong::supernova:: can be called at the same time from multiple threads, write access to global data structures needs
to be synchronized.

definitionList::
## Shared Global Data Structures || Unit generators should not share data structures, which are written to. While it it safe to use
    global data structures for read-only purposes (e.g. different unit generators could use the same constant wavetable),
    the data structures that are modified by the unit generators should not be shared among different instances.

## Resource Locking || SuperCollider's buffers and busses are global data structures, and access needs to be synchronized.
    This is done internally by using reader-writer spinlocks. This is done by using the code::ACQUIRE_::, code::RELEASE_::, and
    code::LOCK_:: macros, which are defined in SC_Unit.h. As exception, buffers in the wavetable format are not required to be
    locked.
::

subsection:: Deadlock Prevention

In order to prevent deadlocks, a simple deadlock prevention scheme is implemented, based on the following constraints.

list::
## Lock resources only when required: few unit generators actually require the access to more than one resource at the same time.
   The main exception of this rule are the FFT Chain ugens, which access multiple buffers at the same time. There is no known unit
   generator, which accesses both buffers and busses at the same time.
## Acquire reader locks if possible. Since multiple ugens can acquire a reader lock to the same resource at the same time, their
   use reduces contention.
## Resources have to be acquired in a well-defined order: busses should be acquired before buffers and resources with a high index
   should be acquired before resources with a low index.
::
