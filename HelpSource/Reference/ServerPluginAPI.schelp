title:: Server Plugin API
summary:: Writing unit generators
categories:: Internals

section:: Input rates

These four constants identify the calculation rates of inputs in SuperCollider.

definitionlist::
## code::calc_ScalarRate::
|| Initial rate. Conventionally known in the language as ".ir".

## code::calc_BufRate::
|| Control rate. Conventionally known in the language as ".kr". 

## code::calc_FullRate::
|| Audio rate. Conventionally known in the language as ".ar".

## code::calc_DemandRate::
|| Demand rate. 
::

section:: UGen I/O

definitionlist::
## code::IN(index)::
|| A single block of audio-rate input as a float* at the given index. Index 0 is the first input to the ugen, index 1 the second input, and so forth.

## code::IN0(index)::
|| A single sample of control-rate input as a float, at the given index.

## code::OUT(index)::
|| A single block of audio-rate output as a float* at the given index.

## code::OUT0(index)::
|| A single sample of control-rate input as a float, at the given index.

## code::INRATE(index)::
|| Get the rate of a given input index. This will be one of the four rates.
::

section:: Unary operators

definitionlist::
## code::bool sc_isnan(float/double x)::
|| Is code::x:: NaN?

## code::bool sc_isfinite(float/double x)::
|| Is code::x:: finite?

## code::int32 sc_grayCode(int32 x)::
|| Convert binary to Gray code.
::

The following unary functions are available for both float32 and float64, and are the same as in sclang (minus the "sc_" prefixes):

code::
sc_log2
sc_log10
sc_midicps
sc_cpsmidi
sc_midiratio
sc_ratiomidi
sc_octcps
sc_cpsoct
sc_ampdb
sc_dbamp
sc_cubed
sc_sqrt
sc_hanwindow
sc_welwindow
sc_triwindow
sc_rectwindow
sc_scurve
sc_ramp
sc_sign
sc_distort
sc_softclip
sc_trunc
sc_ceil
sc_floor
sc_reciprocal
sc_frac
::

The following unary functions are available for both float32 and float64, but have no sclang equivalent:

definitionlist::
## code::zapgremlins(x)::
|| Replaces NaNs, infinities, very large and very small numbers (including denormals) with zero. This is useful in ugen feedback to safeguard from pathological behavior. (Note lack of sc_ prefix.)

## code::sc_bitriwindow::
|| Alternative to code::sc_triwindow:: using absolute value.

## code::sc_scurve0(x)::
|| Same as code::sc_scurve::, but assumes that code::x:: is in the interval [0, 1].

## code::sc_distortneg(x)::
|| A one-sided distortion function. Same as code::distort:: for code::x > 0::, and the identity function for code::x <= 0::.

## code::taylorsin(x)::
|| Taylor series approximation of code::sin(x):: out to code::x**9 / 9!::. (Note lack of sc_ prefix.)

## code::sc_lg3interp(x1, a, b, c, d)::
|| Cubic Lagrange interpolator.

## code::sc_CalcFeedback(delaytime, decaytime)::
|| Determines the feedback coefficient for a feedback comb filter with the given delay and decay times.

## code::sc_wrap1(x)::
|| Same as code::sc_wrap::, but wraps only once.

## code::sc_fold1(x)::
|| Same as code::sc_fold::, but folds only once.
::

section:: Unroll macros

Audio-rate ugens often use loops that look like this:

code::
float* in = IN(0);
float* out = OUT(0);
for (int i = 0; i < inNumSamples; i++) {
	out[i] = in[i] * 0.5;
}
::

The indexing operations code::out[i]:: and code::in[i]:: invoke pointer addition at every sample. We can speed this up by using increments rather than addition, and speed it up further by using pre-increments, not post-increments (so there is no need for the CPU to preserve the old value). The result is the following:

code::
float* in = IN(0) - 1;
float* out = OUT(0) - 1;
for (int i = 0; i < inNumSamples; i++) {
	*(++out) = *(++in) * 0.5;
}
::

A header file by the name of "Unroll.h" provides macros that clean up this code a bit:

code::
float* in = ZIN(0);
float* out = ZOUT(0);
LOOP1(inNumSamples,
	ZXP(out) = ZXP(in) * 0.5;
);
::

These seem like negligible improvements, but real-time audio can be very sensitive to efficiency losses. Many of SC's built-in ugens use the above format.

definitionlist::
## code::LOOP(length, stmt)::
|| Execute code code::stmt::, code::length:: times.

## code::LOOP1(length, stmt)::
|| A faster drop-in alternative to code::LOOP::, which assumes that code::length > 0:: so a branch instruction is saved. This is recommended for the well-known "inNumSamples loop" because inNumSamples is never zero.

## code::LooP(length) stmt::
|| An alternative to LOOP/LOOP1 that is more debugger-friendly. The body of the loop comes after the call to code::LooP::.

## code::ZIN(index)::
|| Similar to code::IN::, but subtracts 1 from the pointer to correct for off-by-one errors when using code::LOOP:: and code::ZXP::.

## code::ZOUT(index)::
|| Same as code::OUT::, but subtracts 1 from the pointer to correct for off-by-one errors when using code::LOOP:: and code::ZXP::.

## code::ZIN0(index)::
|| Alias for code::IN0::. 

## code::ZOUT0(index)::
|| Alias for code::OUT0::.

## code::ZXP(z)::
|| Pre-increment and dereference code::z::.

## code::ZX(z)::
|| Dereference code::z::.

## code::PZ(z)::
|| Pre-increment code::z::.

## code::ZP(z)::
|| Does nothing.

## code::ZOFF::
|| Return 1.
::

The macros on this list -- especially the last few -- seem odd and unnecessary, and that is because the Unroll macros are designed to be swappable in case a platform is found where post-increment is faster.